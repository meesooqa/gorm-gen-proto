package services

import (
	"fmt"
	"log/slog"
	"testing"

	"github.com/stretchr/testify/require"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
)

// TestDbModel represents a simple database model used for testing.
type TestDbModel struct {
	ID   uint `gorm:"primaryKey"`
	Name string
}

// TestPbModel represents a simple protobuf-like model used for testing.
type TestPbModel struct {
	Id   uint64
	Name string
}

// TestConverter implements the Converter interface for TestDbModel and TestPbModel.
type TestConverter struct{}

// DataDbToPb converts a TestDbModel to a TestPbModel.
func (tc TestConverter) DataDbToPb(dbItem *TestDbModel) *TestPbModel {
	return &TestPbModel{
		Id:   uint64(dbItem.ID),
		Name: dbItem.Name,
	}
}

// DataPbToDb converts a TestPbModel to a TestDbModel.
// Note that the ID is omitted as it will be generated by the database.
func (tc TestConverter) DataPbToDb(pbItem *TestPbModel) *TestDbModel {
	return &TestDbModel{
		Name: pbItem.Name,
	}
}

// setupTestDB creates an in-memory SQLite database and migrates the TestDbModel.
func setupTestDB(t *testing.T) *gorm.DB {
	db, err := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{})
	require.NoError(t, err, "failed to open in-memory database")
	err = db.AutoMigrate(&TestDbModel{})
	require.NoError(t, err, "failed to migrate TestDbModel")
	return db
}

// newTestService initializes a new BaseService instance for testing.
func newTestService(t *testing.T) *BaseService[TestDbModel, TestPbModel] {
	db := setupTestDB(t)
	logger := slog.Default()
	return NewBaseService[TestDbModel, TestPbModel](logger, db, TestConverter{})
}

// nameFilter returns a FilterFunc that filters TestDbModel records by Name.
// This filter uses the standard LIKE operator, which in SQLite is case-insensitive by default.
func nameFilter(name string) FilterFunc {
	return func(db *gorm.DB) *gorm.DB {
		return db.Where("name LIKE ?", "%"+name+"%")
	}
}

// TestGetItem verifies that GetItem returns the expected record or an error if not found.
func TestGetItem(t *testing.T) {
	service := newTestService(t)
	// Create a test record.
	testRecord := &TestDbModel{Name: "Test Item"}
	err := service.db.Create(testRecord).Error
	require.NoError(t, err, "failed to create test record")

	// Retrieve the item via GetItem.
	pbItem, err := service.GetItem(uint64(testRecord.ID))
	require.NoError(t, err, "failed to get existing item")
	require.Equal(t, testRecord.Name, pbItem.Name, "retrieved item name mismatch")

	// Attempt to get a non-existent item; expect an error.
	_, err = service.GetItem(999)
	require.Error(t, err, "expected error when item does not exist")
	require.Contains(t, err.Error(), "item with ID", "error message should indicate missing item")
}

// TestCreateItem verifies that CreateItem successfully creates a new record.
func TestCreateItem(t *testing.T) {
	service := newTestService(t)
	pbInput := &TestPbModel{Name: "New Item"}
	pbResult, err := service.CreateItem(pbInput)
	require.NoError(t, err, "failed to create new item")
	require.NotZero(t, pbResult.Id, "expected a non-zero ID for created item")
	require.Equal(t, pbInput.Name, pbResult.Name, "item name mismatch after creation")

	// Verify that the item exists in the database.
	var dbItem TestDbModel
	err = service.db.First(&dbItem, pbResult.Id).Error
	require.NoError(t, err, "failed to find created item in the database")
	require.Equal(t, pbResult.Name, dbItem.Name, "database record name mismatch")
}

// TestUpdateItem verifies that UpdateItem correctly updates an existing record.
func TestUpdateItem(t *testing.T) {
	service := newTestService(t)
	// Create a test record.
	testRecord := &TestDbModel{Name: "Old Name"}
	err := service.db.Create(testRecord).Error
	require.NoError(t, err, "failed to create test record for update")

	// Update the item.
	pbUpdate := &TestPbModel{Name: "Updated Name"}
	pbResult, err := service.UpdateItem(uint64(testRecord.ID), pbUpdate)
	require.NoError(t, err, "failed to update existing item")
	require.Equal(t, pbUpdate.Name, pbResult.Name, "item name not updated correctly")

	// Verify update in the database.
	var updatedRecord TestDbModel
	err = service.db.First(&updatedRecord, testRecord.ID).Error
	require.NoError(t, err, "failed to retrieve updated record from database")
	require.Equal(t, pbUpdate.Name, updatedRecord.Name, "database record not updated correctly")

	// Attempt to update a non-existent item; expect an error.
	_, err = service.UpdateItem(999, pbUpdate)
	require.Error(t, err, "expected error when updating non-existent item")
}

// TestDeleteItem verifies that DeleteItem removes a record and returns an error for non-existent items.
func TestDeleteItem(t *testing.T) {
	service := newTestService(t)
	// Create a test record.
	testRecord := &TestDbModel{Name: "To be deleted"}
	err := service.db.Create(testRecord).Error
	require.NoError(t, err, "failed to create test record for deletion")

	// Delete the item.
	err = service.DeleteItem(uint64(testRecord.ID))
	require.NoError(t, err, "failed to delete existing item")

	// Verify that the item is deleted.
	var count int64
	service.db.Model(&TestDbModel{}).Where("id = ?", testRecord.ID).Count(&count)
	require.Equal(t, int64(0), count, "expected zero records after deletion")

	// Attempt to delete a non-existent item; expect an error.
	err = service.DeleteItem(999)
	require.Error(t, err, "expected error when deleting non-existent item")
	require.Contains(t, err.Error(), "item with ID", "error message should indicate missing item")
}

// TestGetList verifies that GetList returns the correct set of records with filters, sorting, and pagination.
func TestGetList(t *testing.T) {
	service := newTestService(t)
	// Insert multiple test records.
	names := []string{"Alice", "Bob", "Charlie", "David", "Eve"}
	for _, n := range names {
		err := service.db.Create(&TestDbModel{Name: n}).Error
		require.NoError(t, err, fmt.Sprintf("failed to create record for name %s", n))
	}

	// Test without filters: get all items, sorted by name ascending, with pagination (pageSize=2, page=1).
	items, total, err := service.GetList(nil, "name", "asc", 2, 1)
	require.NoError(t, err, "failed to get list of items without filters")
	require.Equal(t, int64(len(names)), total, "total count mismatch")
	require.Len(t, items, 2, "expected 2 items on page 1")
	require.Equal(t, "Alice", items[0].Name, "unexpected first item")
	require.Equal(t, "Bob", items[1].Name, "unexpected second item")

	// Test filtering: get items with name containing "o".
	filters := []FilterFunc{nameFilter("o")}
	items, total, err = service.GetList(filters, "name", "asc", 10, 1)
	require.NoError(t, err, "failed to get list of items with filter")
	// In SQLite, LIKE is case-insensitive by default.
	// Expect to match "Bob" only.
	require.Equal(t, int64(1), total, "expected total count of 1 for filter 'o'")
	require.Len(t, items, 1, "expected 1 item for filter 'o'")
	require.Equal(t, "Bob", items[0].Name, "unexpected item for filter 'o'")

	// Test sorting in descending order.
	t.Run("SortingDescending", func(t *testing.T) {
		items, _, err := service.GetList(nil, "name", "desc", 10, 1)
		require.NoError(t, err, "failed to get list with descending sort")
		// Expected descending order: Eve, David, Charlie, Bob, Alice.
		require.Equal(t, "Eve", items[0].Name, "unexpected first item in descending order")
		require.Equal(t, "Alice", items[len(items)-1].Name, "unexpected last item in descending order")
	})

	// Test pagination: page 2 with pageSize=2 should return the 3rd and 4th records.
	t.Run("Pagination", func(t *testing.T) {
		items, _, err := service.GetList(nil, "name", "asc", 2, 2)
		require.NoError(t, err, "failed to get paginated list")
		require.Len(t, items, 2, "expected 2 items on page 2")
		require.Equal(t, "Charlie", items[0].Name, "unexpected first item on page 2")
		require.Equal(t, "David", items[1].Name, "unexpected second item on page 2")
	})
}
